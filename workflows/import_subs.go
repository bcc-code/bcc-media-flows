package workflows

import (
	"fmt"
	"strings"

	vsactivity "github.com/bcc-code/bcc-media-flows/activities/vidispine"
	"github.com/bcc-code/bcc-media-flows/paths"
	wfutils "github.com/bcc-code/bcc-media-flows/utils/workflows"

	"github.com/bcc-code/bcc-media-flows/activities"
	"go.temporal.io/sdk/workflow"
)

type ImportSubtitlesFromSubtransInput struct {
	VXID string
}

func ImportSubtitlesFromSubtrans(
	ctx workflow.Context,
	params ImportSubtitlesFromSubtransInput,
) error {
	logger := workflow.GetLogger(ctx)

	options := wfutils.GetDefaultActivityOptions()
	ctx = workflow.WithActivityOptions(ctx, options)

	logger.Info("Starting sub import flow")
	_ = wfutils.NotifyTelegramChannel(ctx, "ðŸŸ¦ Starting sub import for VXID: "+params.VXID)

	err := doImportSubtitlesFromSubtrans(ctx, params)
	if err != nil {
		_ = wfutils.NotifyTelegramChannel(ctx, fmt.Sprintf("ðŸŸ¥ Sub import for VXID: %s failed\n\n```%s```", params.VXID, err.Error()))
		return err
	}
	_ = wfutils.NotifyTelegramChannel(ctx, "ðŸŸ© Sub import for VXID: "+params.VXID+" finished")
	return nil
}

func doImportSubtitlesFromSubtrans(ctx workflow.Context, params ImportSubtitlesFromSubtransInput) error {
	logger := workflow.GetLogger(ctx)

	input := activities.GetSubtransIDInput{
		VXID:     params.VXID,
		NoSubsOK: true,
	}

	subtransIDResponse := &activities.GetSubtransIDOutput{}
	err := wfutils.Execute(ctx, activities.Util.GetSubtransIDActivity, input).Get(ctx, subtransIDResponse)
	if err != nil {
		return err
	}

	outputPath, _ := wfutils.GetWorkflowAuxOutputFolder(ctx)

	subsList := map[string]paths.Path{}
	err = wfutils.Execute(ctx, activities.Util.GetSubtitlesActivity, activities.GetSubtitlesInput{
		SubtransID:        subtransIDResponse.SubtransID,
		Format:            "srt",
		ApprovedOnly:      false,
		DestinationFolder: outputPath,
		//FilePrefix:        "subs_", <-- Generated by subtrans if empty
	}).Get(ctx, &subsList)
	if err != nil {
		return err
	}

	var langs []string
	subsKeys, err := wfutils.GetMapKeysSafely(ctx, subsList)
	if err != nil {
		return err
	}

	for _, lang := range subsKeys {
		sub := subsList[lang]
		lang := strings.ToLower(lang)

		jobRes := &vsactivity.JobResult{}
		err = wfutils.Execute(ctx, activities.Vidispine.ImportFileAsShapeActivity, vsactivity.ImportFileAsShapeParams{
			AssetID:  params.VXID,
			FilePath: sub,
			ShapeTag: fmt.Sprintf("sub_%s_%s", lang, "srt"),
			Replace:  true,
		}).Get(ctx, jobRes)

		if jobRes.JobID == "" {
			logger.Info("No job created for importing subtitle shape", "lang", lang, "file", sub)
			continue
		}

		langs = append(langs, lang)

		_ = wfutils.Execute(ctx, activities.Vidispine.WaitForJobCompletion, vsactivity.WaitForJobCompletionParams{
			JobID:     jobRes.JobID,
			SleepTime: 10,
		}).Get(ctx, nil)
	}

	_ = wfutils.NotifyTelegramChannel(
		ctx,
		fmt.Sprintf("Sub import for VXID: %s finished (%s). Starting preview import.", params.VXID, strings.Join(langs, ", ")),
	)

	for _, lang := range subsKeys {
		sub := subsList[lang]
		lang := strings.ToLower(lang)

		jobRes := &vsactivity.JobResult{}
		err := wfutils.Execute(ctx, activities.Vidispine.ImportFileAsSidecarActivity, vsactivity.ImportSubtitleAsSidecarParams{
			AssetID:  params.VXID,
			Language: lang,
			FilePath: sub,
		}).Get(ctx, jobRes)

		if err != nil {
			return err
		}

		if jobRes.JobID == "" {
			logger.Info("No job created for importing subtitle", "lang", lang, "file", sub)
			continue
		}

		_ = wfutils.Execute(ctx, activities.Vidispine.WaitForJobCompletion, vsactivity.WaitForJobCompletionParams{
			JobID:     jobRes.JobID,
			SleepTime: 10,
		}).Get(ctx, nil)
	}

	return nil
}
